import Mathlib.Data.Real.Basic
import Mathlib.Order.Monotone.Basic
import Mathlib.Algebra.Order.Ring.Basic
import Mathlib.Tactic

/-
# Announcements

Assignment 6 is online.

Jeremy will be back on Wednesday.

# Agenda

- more about induction on the natural numbers
- induction on other structures.
-/

/-
Here is how the natural numbers are defined in Lean.
-/

inductive my_nat
  | zero : my_nat
  | succ : my_nat → my_nat

namespace my_nat

def add : my_nat → my_nat → my_nat
  | x, zero   => x
  | x, succ y => succ (add x y)

def mul : my_nat → my_nat → my_nat
  | _, zero   => zero
  | x, succ y => add x (mul x y)

/- Let's prove two or three `my_nat` lemmas. -/

theorem add_zero (n : my_nat) : add n zero = n := by
  rfl -- true by definition

theorem zero_add (n : my_nat) : add zero n = n := by
  -- rfl -- doesn't work, not true by definition
  induction' n with n ih
  . rfl
  . rw [add, ih]

theorem add_succ (n m : my_nat) : add n (succ m) = succ (add n m) := by
  rfl

theorem succ_add (m n : my_nat) : add (succ m) n = succ (add m n) := by
  sorry -- execise, induction'

theorem add_comm (m n : my_nat) : add m n = add n m := by
  induction' n with n ih
  . simp [add_zero, zero_add]
  . simp [add, ih, succ_add]

theorem add_assoc (m n k : my_nat) : add (add m n) k = add m (add n k) := by
  induction' k with k ih
  . simp [add_zero]
  . simp [add_succ, ih]

-- Define infix operator syntax for readability.
-- `local` so that it's only in scope until `end my_nat`.
local infix:50 " + " => add
local infix:60 " * " => mul

theorem mul_add  (m n k : my_nat) : mul m (add n k) = add (mul m n) (mul m k) := by
  induction' k with k ih
  . simp [add_zero, mul]
  . simp [add_succ, mul, ih, ← add_assoc, add_comm m (m*n)]

theorem zero_mul (n : my_nat) : mul zero n = zero := by
  sorry -- exercise

theorem succ_mul (m n : my_nat) : mul (succ m) n = add (mul m n) n := by
  sorry -- exercise

theorem mul_comm (m n : my_nat) : mul m n = mul n m := by
  sorry -- exercise

end my_nat

/-
Later we will consider other types of induction on the natural numbers.

But the one we have considered so far is called "structural induction":
- The natural numbers are generated by a "0" and a "succ" operation.
- You can prove a property holds of all numbers by showing that it holds of 0
  and that it is preserved by the "succ" operation.
- You can define a function by recursion on the natural numbers by giving its
  value at 0 and showing how to compute its value at "succ n" from its value at "n".

To mathematicians, the natural numbers are the only inductive structure we need.
Everything else can be defined from there.
(Kronecker: "God gave us the natural numbers, everything else is the work of mankind.")

But in computer science,
it is useful to view other important data types as inductively defined
because that means we can define functions by recursion
and prove things about them by induction.

Some examples (talk through these):
- Lists: generated by [] and cons
- Binary trees
- Formulas
-/

/-
Lists
-/

namespace hide

inductive List (α : Type*) where
  | nil : List α
  | cons : α → List α → List α

open List

-- examples of `List α` for different `α`
#check (cons 20 (cons 20 nil) : List Nat)
#check (cons "a" (cons "b" nil) : List String)
#check (cons true (cons false nil) : List Bool)

end hide

/-
Question:
Recall that `Unit` is a type with only one element.
What type is `List Unit` equivalent to?
A : `Nat`.
-/
#check (Unit.unit : Unit) -- the one element

-- There is a bijection `List Unit ≃ ℕ`.
#check [Unit.unit, Unit.unit] -- corresponds to `2 : ℕ`
#check [Unit.unit, Unit.unit, Unit.unit] -- `3 : ℕ`
#check [Unit.unit] -- `1 : ℕ`
#check [] -- `0 : ℕ`

/-
Binary Trees
-/

inductive BinaryTree where
  | empty : BinaryTree
  | node : BinaryTree → BinaryTree → BinaryTree

/-
The tree
+
| \
· +
  | \
  · ·
is defined as
-/
open BinaryTree in
#check node empty (node empty empty)

/-
Formulas
-/

inductive PropForm : Type where
  -- Variables
  | var (n : ℕ)           : PropForm
  -- False: ⊥
  | fls                   : PropForm
  -- Conjunction: A ∧ B
  | conj (A B : PropForm) : PropForm
  -- Disjunction: A ∨ B
  | disj (A B : PropForm) : PropForm
  -- Implication: A ⇒ B
  | impl (A B : PropForm) : PropForm

/-
Induction on lists.
-/

#check List
#print List

section

variable {α β γ : Type*}
variable (as bs cs : List α)
variable (a b c : α)

#check a :: as
#check as ++ bs

open List

example : [] ++ as = as := nil_append as
example : [] ++ as = as := rfl -- by definition

example : (a :: as) ++ bs = a :: (as ++ bs) := cons_append a as bs

theorem append_nil' : as ++ [] = as := by
  induction' as with a as ih
  . rfl
  . rw [cons_append, ih]

theorem append_assoc' : as ++ bs ++ cs = as ++ (bs ++ cs) := by
  sorry -- exercise, more induction

-- Also called `snoc` (`cons` but backwards).
-- Aside: `concat'` has time complexity `O(|l|)` where `l` is the input list.
def concat' : List α → α → List α
  | [],      a => [a]
  | b :: bs, a => b :: (concat' bs a)

/-
Another example:
-/

#eval map (fun n => n^2) [1, 2, 3, 4, 5]

-- We write the argument that doesn't vary in recursive calls on the left-hand side of `:` (the colon).
def map' (f : α → β) : List α → List β
  | []      => []
  | a :: as => f a :: map' f as

#eval map' (fun n => n^2) [1, 2, 3, 4, 5]

/- Aside: definitional equality -/
def foo : Nat := 2

example : foo = 2 := by
  rfl -- by definition

theorem map'_map' (f : α → β) (g : β → γ) (as : List α) :
    map' g (map' f as) = map' (g ∘ f) as := by
  induction' as with a as ih
  -- . rw [map', map', map']
  . simp [map']
  -- . rw [map', map', map', ih]
  --   rfl
  .  simp [map', ih]
  -- . rw [map', map', map']
  --   exact congrArg (cons _) ih

#check congrArg

/-
Reversing a list.
-/

-- Question: why is this a bad definition? There are two reasons.
-- Answer 1: it's slow, `O(|l|^2)`.
-- Answer 2: it's not tail-recursive.
-- (A function `foo` is tail-recursive
-- when in any recursive call from `foo` to itself
-- `foo` is the "top-level expression"/"last function called".)
-- If we had `| a :: as => bad_reverse ?`,
-- then `bad_reverse` would be tail-recursive.
def bad_reverse : List α → List α
  | []      => []
  | a :: as => concat' (bad_reverse as) a

-- Non-tail-recursive functions use a new stack frame at each recursive call.
-- Stack overflow!
--#eval bad_reverse (List.range 10000)
