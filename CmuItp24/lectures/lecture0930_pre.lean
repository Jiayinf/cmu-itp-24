import Mathlib.Data.Real.Basic
import Mathlib.Order.Monotone.Basic
import Mathlib.Algebra.Order.Ring.Basic
import Mathlib.Tactic

/-
# Announcements

Assignment 6 is online.

Jeremy will be back on Wednesday.

# Agenda

- more about induction on the natural numbers
- induction on other structures.
-/

/-
Here is how the natural numbers are defined in Lean.
-/

inductive my_nat
  | zero : my_nat
  | succ : my_nat → my_nat

namespace my_nat

def add : my_nat → my_nat → my_nat
  | x, zero   => sorry
  | x, succ y => sorry

def mul : my_nat → my_nat → my_nat
  | x, zero   => sorry
  | x, succ y => sorry

/- Let's prove two or three `my_nat` lemmas. -/

theorem add_zero (n : my_nat) : add n zero = n := by
  sorry

theorem zero_add (n : my_nat) : add zero n = n := by
  sorry

theorem add_succ (n m : my_nat) : add n (succ m) = succ (add n m) := by
  sorry

theorem succ_add (m n : my_nat) : add (succ m) n = succ (add m n) := by
  sorry

theorem add_comm (m n : my_nat) : add m n = add n m := by
  sorry

theorem add_assoc (m n k : my_nat) : add (add m n) k = add m (add n k) := by
  sorry

theorem mul_add  (m n k : my_nat) : mul m (add n k) = add (mul m n) (mul m k) := by
  sorry

theorem zero_mul (n : my_nat) : mul zero n = zero := by
  sorry

theorem succ_mul (m n : my_nat) : mul (succ m) n = add (mul m n) n := by
  sorry

theorem mul_comm (m n : my_nat) : mul m n = mul n m := by
  sorry

end my_nat

/-
Later we will consider other types of induction on the natural numbers.

But the one we have considered so far is called "structural induction":
- The natural numbers are generated by a "0" and a "succ" operation.
- You can prove a property holds of all numbers by showing that it holds of 0
  and that it is preserved by the "succ" operation.
- You can define a function by recursion on the natural numbers by giving its
  value at 0 and showing how to compute its value at "succ n" from its value at "n".

To mathematicians, the natural numbers are the only inductive structure we need.
Everything else can be defined from there.
(Kronecker: "God gave us the natural numbers, everything else is the work of mankind.")

But in computer science,
it is useful to view other important data types as inductively defined
because that means we can define functions by recursion
and prove things about them by induction.

Some examples (talk through these):
- Lists: generated by [] and cons
- Binary trees
- Formulas
-/

/-
Lists
-/

namespace hide

inductive List (α : Type*) where
  | nil : List α
  | cons : α → List α → List α

end hide

/-
Question:
Recall that `Unit` is a type with only one element.
What type is `List Unit` equivalent to?
-/

/-
Binary Trees
-/

inductive BinaryTree where
  | empty : BinaryTree
  | node : BinaryTree → BinaryTree → BinaryTree

/-
Formulas
-/

inductive PropForm : Type where
  -- Variables
  | var (n : ℕ)           : PropForm
  -- False: ⊥
  | fls                   : PropForm
  -- Conjunction: A ∧ B
  | conj (A B : PropForm) : PropForm
  -- Disjunction: A ∨ B
  | disj (A B : PropForm) : PropForm
  -- Implication: A ⇒ B
  | impl (A B : PropForm) : PropForm

/-
Induction on lists.
-/

-- #check List
-- #print List

section

variable {α β γ : Type*}
variable (as bs cs : List α)
variable (a b c : α)

-- #check a :: as
-- #check as ++ bs

open List

example : [] ++ as = as := nil_append as

example : (a :: as) ++ bs = a :: (as ++ bs) := cons_append a as bs

theorem append_nil' : as ++ [] = as := by
  sorry

theorem append_assoc' : as ++ bs ++ cs = as ++ (bs ++ cs) := by
  sorry

-- Also called `snoc` (`cons` but backwards)
def concat' : List α → α → List α
  | [], a      => sorry
  | b :: bs, a => sorry

/-
Another example:
-/

-- #eval map (fun n => n^2) [1, 2, 3, 4, 5]

def map' (f : α → β) : List α → List β
  | []      => sorry
  | a :: as => sorry

-- #eval map' (fun n => n^2) [1, 2, 3, 4, 5]

theorem map'_map' (f : α → β) (g : β → γ) (as : List α) :
    map' g (map' f as) = map' (g ∘ f) as := by
  sorry

/-
Reversing a list.
-/

-- Question: why is this a bad definition? There are two reasons.
def bad_reverse : List α → List α
  | []      => []
  | a :: as => concat' (bad_reverse as) a

/-- `reverse_aux as acc` reverses `as` and appends `acc` -/
def reverse_aux : List α → List α → List α
  | [],      acc => sorry
  | a :: as, acc => sorry

def reverse' (as : List α) : List α := sorry

theorem reverse_aux_append (as bs cs : List α) :
    reverse_aux (as ++ bs) cs = reverse_aux bs (reverse_aux as cs) := by
  sorry

theorem reverse_aux_append' (as bs cs : List α) :
    reverse_aux as (bs ++ cs) = (reverse_aux as bs) ++ cs := by
  sorry

theorem reverse'_append (as bs : List α) :
    reverse' (as ++ bs) = reverse' bs ++ reverse' as := by
  sorry

end

/- Extra material on finite sets in case we have time left. -/

section

variable {α : Type*} (s : Finset ℕ) (f : ℕ → ℕ) (n : ℕ)

-- #check Finset.sum s f
-- #check Finset.prod s f

open BigOperators
open Finset

example : s.sum f = ∑ x in s, f x := rfl
example : s.prod f = ∏ x in s, f x := rfl

example : (range n).sum f = ∑ x in range n, f x := rfl
example : (range n).prod f = ∏ x in range n, f x := rfl

example (f : ℕ → ℕ) : (∑ x in range 0, f x) = 0 := rfl

example (f : ℕ → ℕ) (n : ℕ) : (∑ x in range n.succ, f x) = (∑ x in range n, f x) + f n := by
  sorry

example (f : ℕ → ℕ) : (∏ x in range 0, f x) = 1 := rfl

example (f : ℕ → ℕ) (n : ℕ) : (∏ x in range n.succ, f x) = (∏ x in range n, f x) * f n := by
  sorry

def fac : ℕ → ℕ
  | 0     => 1
  | n + 1 => (n + 1) * fac n

example (n : ℕ) : fac n = ∏ i in range n, (i + 1) := by
  sorry

theorem sum_id (n : ℕ) : (∑ i in range (n + 1), i) = n * (n + 1) / 2 := by
  sorry

theorem sum_sqr (n : ℕ) : (∑ i in range (n + 1), i^2) = n * (n + 1) * (2*n + 1) / 6 := by
  sorry

end
